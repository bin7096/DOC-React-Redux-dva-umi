# 有状态组件和无状态组件
> `React`中既有传统的`有状态组件（类组件）`，也有新增的`无状态组件（函数式组件）`
## 两种组件形式的区别
* 有状态组件、
  1. 以`class（类）`的形式创建，继承于`React.Component`。
  2. 拥有自己的`state`和`props`，props使用`this.props`接收。
  3. `会`触发生命周期的一系列钩子函数。
```js
import React, { Component } from 'react';
class Person extends Component{
  constructor(props) {
    super(props);
    this.state = { title: '这是一个子组件' };
    console.log(this.props);
  }
  render() {
    return <h1>{ this.state.title }</h1>;
  }
}
```
* 无状态组件
  1. 以`function（函数）`的形式创建，返回一个`JSX语法的组件`。
  2. 函数参数接收`props`，没有自己的`state`。
  3. `不会`触发生命周期的一系列钩子函数。
```js
import React from 'react';
// ES5
function Person(props) {
  return (
    <h1>这是一个子组件</h1>
  )
}
// ES6
let Person = (props) => {
  return (
    <h1>这是一个子组件</h1>
  )
}
// 或
let Person = () => <h1>这是一个子组件</h1>;
```
## 两种组件形式的性能对比
> `有状态组件`是用`class（类）`来生成的，由于类相对来说速度比`function（函数）`慢，影响渲染性能。而且有状态组件还会触发一系列的`声明周期钩子函数`，既导致代码执行效率慢，而且触发的钩子函数也会导致一些其他问题出现。

> `无状态组件`不用维护自己的数据，不用把自己的数据保存到内存中。函数的数据是从`外部接收`的，它仅关注`action（动作）`。函数运行时，会依次完成一系列的动作，并将结果返回，所以它的速度相对于`有状态组件`要快一些。
## 两种组件形式的使用规则
> 有状态组件维护着自身的一套`state（状态）`，同时也能触发生命周期的一系列钩子函数。所以它一般被用来做`容器组件`，在容器组件中维护一套数据，再将数据分发给它下面的`其他无状态的子组件`。

> 无状态组件只关心`传递数据`及`返回组件结构`，所以它一般被用来做`UI组件`。`容器组件`将数据传递给`无状态的子组件`，后者将数据与DOM结合，向父组件返回一个渲染完数据的组件。

> 在`React项目`中，推荐尽可能的使用`无状态组件`，避免过多的`state（状态/数据）`散落于代码中。散落的数据会给后期代码维护造成比较大的困难，这也就是为什么使用`Redux`的原因。